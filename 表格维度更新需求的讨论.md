# 关于表格维度更新需求的讨论

## 原需求图示

<img width="466" height="241" alt="表格维度更新需求详情" src="https://github.com/user-attachments/assets/1d48fbf2-7e3d-4e17-a05b-83b01a6f4dc8" />

## 对于原需求我的实现思路

1. 将用户上传的新增量附件和旧的附件从远程存储服务器中下载下来
2. 比对两表的列数，列内容是否严格匹配（这个我已经写好了工具类）
3. 若列信息严格匹配，将增量附件的信息追加到原附件的末尾
4. 将追加完成的附件重新发送到远程存储服务，同时可以解析追加完成的表格附件为 Markdown（发送和解析尝试异步的执行，不阻塞客户端）
5. 将重新发送到远程存储服务的附件的 URL 和其 Markdown 内容更新至数据库中

### 原需求操作流程图

<img width="1000" height="800" alt="原需求流程图" src="https://github.com/user-attachments/assets/dbc5e50d-0537-4090-b4ca-b3d7addb4e9d"/>

这些操作都太耗时了（尤其是 1 和 4），能不能调整一下表格文件上传、修改的逻辑？

## 我的优化想法

首先，在用户上传表格类型附件的时候，会计算该表表头的哈希值，存储在数据库中
（`tr_knowledge_base_attachment` 数据表也增加相应字段，也可以为专门为表格类型的附件再拆一张表出去存储表头哈希）。

### 文件上传核心代码示例如下（终点关注附件的分支）

```java
@Slf4j
@Service
public class SysCommonServiceImpl implements ISysCommonService
{

	@Value("${by.common.pre-file-url:https://ai-training-uk.oss-cn-hangzhou.aliyuncs.com}")
	private String preFileUrl;

	@Resource
	private OssTemplate ossTemplate;

    /**
     * EXCEL 表格文件转 Markdown 文件 python 脚本路径
     * （可以从配置中读取，也可以硬编码，从 classpath 中读取也行？）
     */
    // @Value()
    private String tableConverterScriptPath
        = "D:\\ai-by-training\\platform\\system\\src\\main\\resources\\py-scripts\\table_converter.py";

    /** 常用的 EXCEL 表格后缀集合。*/
    private final static
    Set<String> EXCEL_SUFFIX_SET
        = Set.of(".xlsx", ".xlsm", ".xlsb", ".xls", ".csv");

	@Override
	public UploadResultVO uploadFile(MultipartFile file, String purpose) throws UploadException
    {
		// 从前端传入的文件不得为 null
        AIByTrainingInterfaceAssert.notNull(file, ErrorCode.EMPTY_PARAM);

        // 获取客户端传来文件的原始文件名（比如：document.pdf test.txt）
		String fileName = Objects.requireNonNull(file.getOriginalFilename());

		log.info(
            "开始上传文件 <{}>，文件大小 = {} bytes.",
            fileName, file.getSize()
        );

        // 记录开始上传文件的时间戳
		long start = System.currentTimeMillis();

        /* 文件会被上传到远程存储服务器，这里保存文件在存储服务器的 URL */
		String fileUrl;

        /* 对于指定格式的文件，在本地会生成一个临时文件，交给其他进程进行相关处理。*/
		File temp = null;

        /* 对于音频或视频类型的文件，会使用 ffprobe 求它的时长（单位：秒） */
		Integer duration = null;

        /* 对于表格附件，解析后的 Markdown 内容存于此处。*/
        String markdownContent = null;

		// 获取文件输入流
        try (InputStream inputStream = file.getInputStream())
        {
            // 若形参中没有指定文件存储目录，默认放在 default 存储目录下
			if (StrUtil.isEmpty(purpose)) {
				purpose = PurposeEnum.DEFAULT.getCode();
			}

			String suffix = ContentType.JPG.getSuffix();

            // 对于存在文件扩展名的文件，提取它
			if (StrUtil.isNotBlank(fileName) && fileName.lastIndexOf(StringPool.DOT) > -1)
            {
				suffix = fileName.substring(
                    fileName.lastIndexOf(StringPool.DOT)
                );
			}

            /*
             * 对于音频或视频文件，需要在本地创建临时文件，
             * 再调用 getDuration() 求时长。
             */
			if (PurposeEnum.VIDEO.getCode().equals(purpose) || PurposeEnum.AUDIO.getCode().equals(purpose))
            {
                /* 临时文件格式：timestamp.suffix */
                temp = File.createTempFile(
                    String.valueOf(System.currentTimeMillis()), suffix
                );

                // 创建临时文件
				file.transferTo(temp);

                // 求音频 / 视频文件的时长
				duration = this.getDuration(temp.getAbsolutePath());
			}

            /*
             * 对于表格附件，
             * 需要在本地创建临时文件，解析成 Markdown 格式再返回给前端。
             */
            if (PurposeEnum.ANNEX.getCode().equals(purpose) && EXCEL_SUFFIX_SET.contains(suffix.toLowerCase()))
            {
                /* 临时文件格式：timestamp.xlsx */
                temp = File.createTempFile(
                    String.valueOf(System.currentTimeMillis()), suffix
                );

                // 创建临时文件
                file.transferTo(temp);

                // 转换成 Markdown 格式字符串
                markdownContent
                    = this.convertTableToMarkdown(
                        tableConverterScriptPath, temp.getAbsolutePath()
                );

                /** 这里再添加一个计算表头哈希的逻辑 */
            }

            /*
             * 组装文件路径，格式：
             * 存储目录/年月/时间戳.扩展名
             *
             * 示例：avatar/202412/1756292250.png
             */
			fileName = purpose + StringPool.SLASH      +
                       YearMonthSdf.format(new Date()) + StringPool.SLASH +
                       System.currentTimeMillis()      + suffix;

            // 上传至远程服务器（这个功能暂时不可用）
			ossTemplate.putObject(fileName, inputStream);

            // 组装文件在远程服务器的 URL
			fileUrl = preFileUrl + StringPool.SLASH + fileName;

		}
        catch (IOException e)
        {
			log.error("", e);
			throw new UploadException(e.getMessage());
		}
        finally
        {
            // 最后不要忘记删除位于本地的临时文件
			if (Objects.nonNull(temp)) { FileUtil.del(temp); }

			log.info("文件上传完成，耗时 {} ms。", System.currentTimeMillis() - start);
		}
        
        /** 返回的响应也带上表头哈希值数据。*/
		return
        UploadResultVO.builder()
            .fileUrl(fileUrl)
            .markdownContent(markdownContent)
            .duration(duration)
            .build();
	}

    /**
     * 将表格附件转化成 Markdown 格式的字符串。
     *
     * @param scriptPath 转换 Python 脚本路径
     * @param tablePath  表格临时文件路径
     *
     * @return 转换后的 Markdownm 格式字符串（如果转换失败则为 null）
     */
    private String
    convertTableToMarkdown(String scriptPath, String tablePath)
    {
        try
        {
            ProcessBuilder builder = new ProcessBuilder(
                "py", scriptPath, tablePath
            );

            Process process = builder.start();

            BufferedReader reader
                = new BufferedReader(
                    new InputStreamReader(
                        process.getInputStream(), StandardCharsets.UTF_8
                    )
            );

            /*
             * 转换过程中若出现错误，
             * 脚本会向 stderr 发送错误信息，因此这里需要拿到错误流。
             */
            BufferedReader errorReader
                = new BufferedReader(
                    new InputStreamReader(
                        process.getErrorStream(), StandardCharsets.UTF_8
                    )
            );

            String line;
            StringBuilder scriptResult = new StringBuilder();
            StringBuilder errorResult  = new StringBuilder();

            while ((line = reader.readLine()) != null)
            {
                /* 这个 markdown 后续要在前端展示，所以要用 <br> 标签进行换行*/
                scriptResult.append(line).append("<br>");
            }

            while ((line = errorReader.readLine()) != null) {
                errorResult.append(line).append('\n');
            }

            int exitCode = process.waitFor();

            if (exitCode != 0)
            {
                log.error(
                    "表格转换时出现异常！原因：{}", errorResult
                );

                return null;
            }

            return
            scriptResult.toString().trim();
        }
        catch (IOException | InterruptedException e)
        {
            log.error("表格转换 Markdown 时出现异常！", e);
            return null;
        }
    }
}
```

在用户对表格附件点击更新内容时将原来的表格附件下载给用户，让用户在原有的表格上进行修改，然后再上传回去？
基于上面的修改这样后端做的工作会少很多（只需要校验表头哈希，再上传用户新修改的附件），逻辑更简单，速度也更快，

### 具体的流程图如下

<img width="1200" height="1000" alt="原需求流程图" src="https://github.com/user-attachments/assets/bdfc4c27-a641-4af4-98e2-12331ca6ecf9"/>

## 新问题又来了

如果这个附件同时被多个用户修改，我们要如何控制附件的版本？

所以，后续对于这个需求的实现我觉得我们需要再讨论一下。。。

今天又是烧脑的一天。。
